<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basics of Bhagavad-Gita</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #imageContainerTopLeft, #imageContainerTopRight {
            position: absolute;
            width: 100px;
            height: 100px;
            z-index: 10;
        }
        #imageContainerTopLeft {
            top: 5%; /* 5% margin from top */
            left: 5%; /* 5% margin from left */
        }
        #imageContainerTopRight {
            top: 5%; /* 5% margin from top */
            right: 5%; /* 5% margin from right */
        }
        #imageTopLeft, #imageTopRight {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #chariotContainer {
            position: absolute;
            z-index: 10;
        }
        #chariotImage {
            max-width: 200px; /* Reduced from 300px to 200px */
            height: auto;
        }
    </style>
</head>
<body>
    <div id="imageContainerTopLeft">
        <img id="imageTopLeft" src="images/topleft.png" alt="Top Left Image">
    </div>
    <div id="imageContainerTopRight">
        <img id="imageTopRight" src="images/topright.jpg" alt="Top Right Image">
    </div>
    <div id="chariotContainer">
        <img id="chariotImage" src="images/chariot.png" alt="Chariot from Bhagavad Gita">
    </div>
    <script>
        let stars = [];
        let t = 0;
        let nebula;
        let roadGraphic;
        let messages = [
            "Basics of Bhagavad-Gita" // Only second message
        ];
        let typedText = "";
        let charIndex = 0;
        let lastUpdate = 0;
        let typingSpeed = 75; // 75ms per character
        let messageDelay = 3000; // Increased from 1000ms to 3000ms (3 seconds) delay
        let cycleTime = 0;
        let isFirstMessage = true;
        let chariotX, chariotY;
        let holdStartTime = 0; // Track when hold phase starts
        let holdDuration = 3000; // 3 seconds hold duration

        function setup() {
            createCanvas(windowWidth, windowHeight);
            nebula = createGraphics(width, height);
            roadGraphic = createGraphics(width, height);
            generateNebula();
            generateStars();
            generateRoad();
            textFont("Georgia"); // Spiritual and royal font
            textAlign(CENTER, CENTER); // Centered alignment
            textSize(24); // Fixed text size

            // Initialize chariot position (bottom left, adjusted with margin)
            let marginX = width * 0.02;
            let marginY = 10; // Small margin to keep it near bottom without being too thick
            let chariotImage = document.getElementById('chariotImage');
            let imageHeight = chariotImage.naturalHeight * (200 / chariotImage.naturalWidth); // Updated to match 200px width
            chariotX = marginX; // Align with left edge + margin
            chariotY = height - imageHeight - marginY; // Position above bottom with small margin
            document.getElementById('chariotContainer').style.left = chariotX + 'px';
            document.getElementById('chariotContainer').style.top = chariotY + 'px';
        }

        function generateNebula() {
            nebula.loadPixels();
            for (let x = 0; x < nebula.width; x++) {
                for (let y = 0; y < nebula.height; y++) {
                    let n = noise(x * 0.01, y * 0.01) * 255;
                    let alpha = map(n, 0, 255, 0, 100); // Kept max alpha at 100
                    nebula.set(x, y, color(120, 90, 180, alpha)); // Reduced purple intensity
                }
            }
            nebula.updatePixels();
        }

        function generateStars() {
            stars = [];
            let minDim = min(width, height);
            for (let i = 0; i < 300; i++) { // Kept at 300 stars
                let angle = random(TWO_PI); // Random direction toward all corners
                let maxDist = random(100, minDim * 0.7); // Extend max distance to reach corners
                let size = random(1, 3); // Reduced size range
                let twinkleSpeed = random(0.02, 0.05);
                stars.push({ angle, maxDist, size, twinkleSpeed });
            }
        }

        function generateRoad() {
            roadGraphic.clear();
            let initialWidth = width * 0.35;
            let finalWidth = initialWidth * 0.1;
            let numberLayers = 500;
            let segments = 50;
            let sx = 0;
            let sy = height;
            let cx1 = width * 0.4;
            let cy1 = height * 1.0;
            let cx2 = width * 0.6;
            let cy2 = height * 0.7;
            let ex = width;
            let ey = height * 0.5;
            roadGraphic.noFill();
            for (let i = 0; i < numberLayers; i++) {
                let fraction = i / (numberLayers - 1);
                let r = 255;
                let g = map(fraction, 0, 1, 255, 255);
                let b = map(fraction, 0, 1, 255, 150);
                let alpha = map(fraction, 0, 1, 50, 20);
                roadGraphic.stroke(r, g, b, alpha);
                roadGraphic.strokeWeight(1);
                roadGraphic.beginShape();
                for (let j = 0; j <= segments; j++) {
                    let t = j / segments;
                    let x = bezierPoint(sx, cx1, cx2, ex, t);
                    let y = bezierPoint(sy, cy1, cy2, ey, t);
                    let dx = bezierTangent(sx, cx1, cx2, ex, t);
                    let dy = bezierTangent(sy, cy1, cy2, ey, t);
                    let len = sqrt(dx * dx + dy * dy);
                    if (len === 0) len = 1;
                    let px = -dy / len;
                    let py = dx / len;
                    let halfW = map(t, 0, 1, initialWidth / 2, finalWidth / 2);
                    let offset = map(fraction, 0, 1, -halfW, halfW);
                    let offX = x + px * offset;
                    let offY = y + py * offset;
                    roadGraphic.vertex(offX, offY);
                }
                roadGraphic.endShape();
            }
        }

        function drawStar(x, y, radius, alpha) {
            noStroke();
            let glowLayers = 3;
            for (let i = glowLayers; i > 0; i--) {
                let glowRadius = radius * (1 + i * 0.5);
                let glowAlpha = alpha * (i / glowLayers) * 0.5;
                fill(255, 255, 255, glowAlpha);
                circle(x, y, glowRadius * 2);
            }
            fill(255, 255, 255, alpha);
            circle(x, y, radius * 2);
        }

        function drawSun(x, y, alpha) {
            let maxRadius = 50;
            let glowLayers = 20;
            for (let i = glowLayers; i > 0; i--) {
                let radius = (i / glowLayers) * maxRadius;
                let sunAlpha = map(i, 0, glowLayers, 0, alpha);
                fill(255, 200, 100, sunAlpha);
                circle(x, y, radius * 2);
            }
            fill(255, 220, 100, alpha);
            circle(x, y, 20);
        }

        function draw() {
            background(0);
            image(nebula, 0, 0);
            let centerX = width / 2;
            let centerY = height / 2;
            let radiusFactor = abs(sin(t));
            t += 0.01;
            let alpha = 0;

            // Determine the phase: expansion, hold, or contraction
            if (radiusFactor >= 0.99) { // Near maximum expansion
                if (holdStartTime === 0) {
                    holdStartTime = millis(); // Start hold timer
                }
                if (millis() - holdStartTime < holdDuration) {
                    radiusFactor = 1; // Hold at maximum expansion
                    alpha = 200; // Full brightness during hold
                } else {
                    holdStartTime = 0; // Reset hold timer for next cycle
                }
            } else {
                alpha = map(radiusFactor, 0, 1, 50, 200); // Fade during expansion and contraction
            }

            drawSun(centerX, centerY, alpha);
            for (let star of stars) {
                let dist = star.maxDist * radiusFactor; // Expand to corners, hold, then contract
                let x = centerX + cos(star.angle) * dist;
                let y = centerY + sin(star.angle) * dist;
                let twinkle = sin(frameCount * star.twinkleSpeed) * 0.3 + 0.7;
                let starSize = star.size * twinkle;
                drawStar(x, y, starSize, alpha);
            }
            image(roadGraphic, 0, 0);

            // Typing effect with looping transition for only the second message
            if (millis() - lastUpdate >= typingSpeed) {
                cycleTime = millis();
                if (charIndex < messages[0].length) {
                    typedText = messages[0].substring(0, charIndex + 1);
                    charIndex++;
                } else {
                    charIndex = 0;
                    typedText = "";
                    lastUpdate = millis() + messageDelay; // 3-second delay before restarting
                }
                lastUpdate = millis();
            }

            // Spiritual and royal font effect for center message
            push();
            textSize(24); // Fixed text size
            textAlign(CENTER, CENTER); // Centered alignment
            fill(255, 215, 0); // Golden-yellow color
            text(typedText, width / 2, height / 2);
            fill(0, 0, 0, 100); // Black shadow with opacity
            text(typedText, width / 2 + 2, height / 2 + 2);
            pop();

            // Static text at bottom right with right alignment
            push();
            textSize(18); // Fixed text size
            let marginX = width * 0.02; // 2% of width as margin
            let marginY = height * 0.02; // 2% of height as margin
            textAlign(RIGHT, TOP); // Right-aligned text
            fill(255, 215, 0); // Golden-yellow color
            text("Speaker:", width - marginX, height - marginY - 60); // Adjusted Y position for two lines
            text("Rajat Prabhu", width - marginX, height - marginY - 40); // New line for name
            fill(0, 0, 0, 100); // Black shadow
            text("Speaker:", width - marginX - 2, height - marginY - 62); // Shadow for "Speaker:"
            text("Rajat Prabhu", width - marginX - 2, height - marginY - 42); // Shadow for name
            fill(255, 215, 0);
            text("ISKCON PUNE", width - marginX, height - marginY - 20);
            fill(0, 0, 0, 100);
            text("ISKCON PUNE", width - marginX - 2, height - marginY - 22);
            pop();

            // Static text below top right image, center-aligned on two lines
            push();
            textSize(18); // Fixed text size
            textAlign(CENTER, TOP); // Center-aligned text
            textStyle(BOLD); // Bold text
            let topRightX = width - (width * 0.05) - 50; // Center of 100px image at right: 5%
            let topRightY = height * 0.05 + 110; // Below image (5% of height + 100px height + 10px margin)
            fill(255); // White color
            text("REGISTER", topRightX, topRightY);
            text("AT", topRightX, topRightY + 20); // 20px spacing between lines
            fill(0, 0, 0, 100); // Black shadow
            text("REGISTER", topRightX - 2, topRightY + 2);
            text("AT", topRightX - 2, topRightY + 22);
            pop();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            nebula = createGraphics(width, height);
            roadGraphic = createGraphics(width, height);
            generateNebula();
            generateStars();
            generateRoad();

            // Update chariot position on resize
            let marginX = width * 0.02;
            let marginY = 10; // Small margin to keep it near bottom
            let chariotImage = document.getElementById('chariotImage');
            let imageHeight = chariotImage.naturalHeight * (200 / chariotImage.naturalWidth); // Updated to match 200px width
            chariotX = marginX; // Align with left edge + margin
            chariotY = height - imageHeight - marginY; // Position with small margin
            document.getElementById('chariotContainer').style.left = chariotX + 'px';
            document.getElementById('chariotContainer').style.top = chariotY + 'px';
        }
    </script>
</body>
</html>